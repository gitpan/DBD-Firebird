/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of InterBase.xs. Do not edit this file, edit InterBase.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "InterBase.xs"
/*
   $Id: InterBase.xs 394 2008-01-08 05:29:19Z edpratomo $

   Copyright (c) 1999-2008  Edwin Pratomo
   Portions Copyright (c) 2001-2005  Daniel Ritz

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the Perl README file.

*/
/* vim: set noai ts=4 et sw=4: */

#include "InterBase.h"

DBISTATE_DECLARE;

static int _cancel_callback(SV *dbh, IB_EVENT *ev)
{
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);

    int ret = 0;
    if (ev->exec_cb) 
        croak("Can't be called from inside a callback");
    if (ev->perl_cb) {
        ev->state = INACTIVE;
        SvREFCNT_dec(ev->perl_cb);
        ev->perl_cb = (SV*)NULL;
        isc_cancel_events(status, &(imp_dbh->db), &(ev->id));
        if (ib_error_check(dbh, status))
            ret = 0;
        else
            ret = 1;
    } else 
        croak("No callback found for this event handle. Have you called ib_register_callback?");
    return ret;
}

static int _call_perlsub(IB_EVENT ISC_FAR *ev, short length, 
#if defined(INCLUDE_TYPES_PUB_H)
const ISC_UCHAR *updated
#else
char ISC_FAR *updated
#endif
)
{
    int retval = 1;
#if defined(USE_THREADS) || defined(USE_ITHREADS) || defined(MULTIPLICITY)
    /* save context, set context from dbh */
    void *context = PERL_GET_CONTEXT;
    PERL_SET_CONTEXT(ev->dbh->context);
    {
#else
    void *context = PERL_GET_CONTEXT;
    PerlInterpreter *cb_perl = perl_alloc();
    PERL_SET_CONTEXT(cb_perl);
    {
#endif
        dSP;
        int i, count;
        SV **svp;
        HV *posted_events = newHV();
        ISC_ULONG ecount[15];
#if defined(INCLUDE_TYPES_PUB_H)
        ISC_UCHAR *result = ev->result_buffer;
#else
        char ISC_FAR *result = ev->result_buffer;
#endif

        while (length--)
            *result++ = *updated++;
        isc_event_counts(ecount, ev->epb_length, ev->event_buffer,
                         ev->result_buffer);
        for (i = 0; i < ev->num; i++) 
        {
            if (ecount[i])
            {
                svp = hv_store(posted_events, *(ev->names + i), strlen(*(ev->names + i)),
                               newSViv(ecount[i]), 0);
                if (svp == NULL)
                    croak("Bad: key '%s' not stored", *(ev->names + i));
            }
        }
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newRV_noinc((SV*)posted_events)));
        PUTBACK;
        count = perl_call_sv(ev->perl_cb, G_SCALAR);
        SPAGAIN;
        if (count > 0) 
            retval = POPi;
        PUTBACK;
        FREETMPS;
        LEAVE;
#if defined(USE_THREADS) || defined(USE_ITHREADS) || defined(MULTIPLICITY)
    }

    /* restore old context*/
    PERL_SET_CONTEXT(context);
#else
    }
    PERL_SET_CONTEXT(context);
    perl_free(cb_perl);
#endif
    return retval;
}

/* callback function for events, called by InterBase */
/* static isc_callback _async_callback(IB_EVENT ISC_FAR *ev, short length, char ISC_FAR *updated) */
static ISC_EVENT_CALLBACK _async_callback(IB_EVENT ISC_FAR *ev, 
#if defined(INCLUDE_TYPES_PUB_H)
ISC_USHORT length, const ISC_UCHAR *updated
#else
short length, char ISC_FAR *updated
#endif
)
{
    ISC_STATUS status[ISC_STATUS_LENGTH];

    switch (ev->state) {
    case INACTIVE:
        break;
    case ACTIVE:
        ev->exec_cb = 1;
        if (_call_perlsub(ev, length, updated) == 0) {
            ev->state = INACTIVE;
            ev->exec_cb = 0;
            break;
        }
        ev->exec_cb = 0;
        isc_que_events(
            status,
            &(ev->dbh->db),
            &(ev->id),
            ev->epb_length,
            ev->event_buffer,
            (ISC_EVENT_CALLBACK)_async_callback,
            ev
        );
    }
    return (0);
}


#line 156 "InterBase.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 199 "InterBase.c"

/* INCLUDE:  Including 'InterBase.xsi' from 'InterBase.xs' */

#include "Driver_xst.h"

XS(XS_DBD__InterBase__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__dr_dbixs_revision)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "InterBase.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 219 "InterBase.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS(XS_DBD__InterBase__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__dr_discon_all_)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0);
#line 48 "InterBase.xsi"
    D_imp_drh(drh);
    if (0) ix = ix;     /* avoid unused variable warning */
    ST(0) = dbd_discon_all(drh, imp_drh) ? &sv_yes : &sv_no;
#line 246 "InterBase.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS(XS_DBD__InterBase__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__dr_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 62 "InterBase.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 290 "InterBase.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__InterBase__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__login)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	dbname = ST(1);
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 92 "InterBase.xsi"
    {
    STRLEN lna;
    D_imp_dbh(dbh);
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &sv_yes : &sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &sv_yes : &sv_no;
#endif
    }
#line 334 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_selectall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 110 "InterBase.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 356 "InterBase.c"
#line 116 "InterBase.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::InterBase::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 401 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_selectrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 166 "InterBase.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 425 "InterBase.c"
#line 171 "InterBase.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 481 "InterBase.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1


XS(XS_DBD__InterBase__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_do)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 235 "InterBase.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 524 "InterBase.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS(XS_DBD__InterBase__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_last_insert_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	catalog = ST(1);
	SV *	schema = ST(2);
	SV *	table = ST(3);
	SV *	field = ST(4);
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5);
	}
#line 262 "InterBase.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 562 "InterBase.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__InterBase__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_commit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 274 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 586 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_rollback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 284 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 609 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_disconnect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 294 "InterBase.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &sv_yes : &sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 643 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 317 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &sv_no;
#line 671 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_FETCH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 331 "InterBase.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 696 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 342 "InterBase.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* want's ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 762 "InterBase.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS(XS_DBD__InterBase__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_take_imp_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0);
#line 395 "InterBase.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::InterBase::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 799 "InterBase.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS(XS_DBD__InterBase__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 419 "InterBase.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 843 "InterBase.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__InterBase__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st__prepare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	statement = ST(1);
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 448 "InterBase.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &sv_yes : &sv_no;
#endif
    }
#line 881 "InterBase.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS(XS_DBD__InterBase__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_rows)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 465 "InterBase.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 905 "InterBase.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS(XS_DBD__InterBase__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_bind_col)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	col = ST(1);
	SV *	ref = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 480 "InterBase.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &sv_yes : &sv_no;
                break;
    default:    ST(0) = &sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 965 "InterBase.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS(XS_DBD__InterBase__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_bind_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 518 "InterBase.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &sv_yes : &sv_no;
    }
#line 1014 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_bind_param_inout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 548 "InterBase.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &sv_yes : &sv_no;
    }
#line 1068 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_execute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0);
#line 579 "InterBase.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1105 "InterBase.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS(XS_DBD__InterBase__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_execute_for_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0);
	SV *	fetch_tuple_sub = ST(1);
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2);
	}
#line 607 "InterBase.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1139 "InterBase.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__InterBase__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 622 "InterBase.xsi"
    D_imp_sth(sth);
    AV *av;
    if (0) ix = ix;     /* avoid unused variable warning */
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1165 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchrow_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 635 "InterBase.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        if (0) ix = ix; /* avoid unused variable warning */
    }
#line 1199 "InterBase.c"
	PUTBACK;
	return;
    }
}


XS(XS_DBD__InterBase__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 655 "InterBase.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::InterBase::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 1241 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_finish)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 669 "InterBase.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &sv_yes : &sv_no;
#endif
#line 1277 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_blob_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 697 "InterBase.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1321 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 713 "InterBase.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &sv_no;
#line 1349 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_FETCH_attrib)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 730 "InterBase.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    if (0) ix = ix;     /* avoid unused variable warning */
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1377 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 743 "InterBase.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1429 "InterBase.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'InterBase.xs' from 'InterBase.xsi' */


XS(XS_DBD__InterBase__db__do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__do)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, attr=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	statement = ST(1);
	SV *	attr;

	if (items < 3)
	    attr = Nullsv;
	else {
	    attr = ST(2);
	}
#line 159 "InterBase.xs"
{
    D_imp_dbh(dbh);
    ISC_STATUS status[ISC_STATUS_LENGTH]; /* isc api status vector    */
    STRLEN     slen;
    int        retval;
    char       *sbuf = SvPV(statement, slen);

    DBI_TRACE_imp_xxh(imp_dbh, 1, (DBIc_LOGPIO(imp_dbh), "db::_do\n" "Executing : %s\n", sbuf));

    /* we need an open transaction */
    if (!imp_dbh->tr)
    {
        DBI_TRACE_imp_xxh(imp_dbh, 1, (DBIc_LOGPIO(imp_dbh), "starting new transaction..\n"));

        if (!ib_start_transaction(dbh, imp_dbh))
        {
            retval = -2;
            XST_mUNDEF(0);      /* <= -2 means error        */
            return;
        }

        DBI_TRACE_imp_xxh(imp_dbh, 1, (DBIc_LOGPIO(imp_dbh), "new transaction started.\n"));
    }

    /* we need to count the DDL statement whether in soft / hard commit */
#if 0
    /* only execute_immediate statment if NOT in soft commit mode */
    if (!(imp_dbh->soft_commit))
    {
        isc_dsql_execute_immediate(status, &(imp_dbh->db), &(imp_dbh->tr), 0,
                                   sbuf, imp_dbh->sqldialect, NULL);

        if (ib_error_check(dbh, status))
            retval = -2;
        else
            retval = -1 ;
    }
    else
#endif
    /* count DDL statements is necessary for ib_commit_transaction to work properly */
    {
        isc_stmt_handle stmt = 0L;        /* temp statment handle */
        static char     stmt_info[] = { isc_info_sql_stmt_type };
        char            info_buffer[20];  /* statment info buffer */

        retval = -2;

        do
        {
            /* init statement handle */
            if (isc_dsql_alloc_statement2(status, &(imp_dbh->db), &stmt))
                break;

            /* prepare statement */
            isc_dsql_prepare(status, &(imp_dbh->tr), &stmt, 0, sbuf,
                             imp_dbh->sqldialect, NULL);
            if (ib_error_check(dbh, status))
                break;

            /* get statement type */
            if (!isc_dsql_sql_info(status, &stmt, sizeof(stmt_info), stmt_info,
                              sizeof(info_buffer), info_buffer))
            {
                /* need to count DDL statments */
                short l = (short) isc_vax_integer((char *) info_buffer + 1, 2);
                if (isc_vax_integer((char *) info_buffer + 3, l) == isc_info_sql_stmt_ddl)
                    imp_dbh->sth_ddl++;
            }
            else
                break;

            /* exec the statement */
            isc_dsql_execute(status, &(imp_dbh->tr), &stmt, imp_dbh->sqldialect, NULL);
            if (!ib_error_check(dbh, status))
                retval = -1;

        } while (0);

        /* close statement */
        if (stmt)
           isc_dsql_free_statement(status, &stmt, DSQL_drop);

        if (retval != -2) retval = -1;
    }

    /* for AutoCommit: commit */
    if (DBIc_has(imp_dbh, DBIcf_AutoCommit))
    {
        if (!ib_commit_transaction(dbh, imp_dbh))
            retval = -2;
    }

    if (retval < -1)
        XST_mUNDEF(0);
    else
        XST_mIV(0, retval); /* typically 1, rowcount or -1  */
}
#line 1557 "InterBase.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db__ping); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__ping)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 261 "InterBase.xs"
{
    int ret;
    ret = dbd_db_ping(dbh);
    if (ret == 0)
        XST_mUNDEF(0);
    else
        XST_mIV(0, ret);
}
#line 1584 "InterBase.c"
    }
    XSRETURN(1);
}

#define TX_INFOBUF(name, len) \
if (strEQ(item, #name)) { \
    *p++ = (char) isc_info_tra_##name; \
    res_len += len + 3; \
    item_buf_len++; \
    continue; \
}
#define TX_RESBUF_CASE(name) \
case isc_info_tra_##name:\
{\
    keyname = #name;\
    /* PerlIO_printf(PerlIO_stderr(), "Got %s\n", keyname); */\
    p++;\
    length = isc_vax_integer (p, 2);\
    p += 2;\
    (void)hv_store(RETVAL, keyname, strlen(keyname), \
             newSViv(isc_vax_integer(p, (short) length)), 0);\
    p += length;\
    break;\
}

XS(XS_DBD__InterBase__db_ib_tx_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_tx_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV*	dbh = ST(0);
#line 296 "InterBase.xs"
    char* p;
    char* result = NULL;
    short result_length = 0;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 1627 "InterBase.c"
	HV *	RETVAL;
#line 301 "InterBase.xs"
{
    D_imp_dbh(dbh);
    char request[] = {
        isc_info_tra_id, 
#if defined(FB_API_VER) && FB_API_VER >= 20
        /* FB 2.0: */
        isc_info_tra_oldest_interesting,
        isc_info_tra_oldest_active,
        isc_info_tra_oldest_snapshot,
        isc_info_tra_lock_timeout,
        isc_info_tra_isolation,
        isc_info_tra_access,
#endif
        isc_info_end
    };

    RETVAL = newHV();
    if (!RETVAL) {
        if (result) {
            Safefree(result);
        }
        do_error(dbh, 2, "unable to allocate hash return value");
        XSRETURN_UNDEF;
    }

    if (!imp_dbh->tr) {
        do_error(dbh, 2, "No active transaction");
        XSRETURN_UNDEF;
    } 

    /* calc required result buffer size */
    for (p = request; *p != isc_info_end; p++) {
        result_length++; /* identifier (1 byte)*/
        switch (*p) {
#if defined(FB_API_VER) && FB_API_VER >= 20
            case isc_info_tra_isolation:
                /* result: 
                length (2 bytes) + first content (1 byte) +
                length (2 bytes) + second content (2 bytes max)
                */
                result_length += 7;
                break;
            case isc_info_tra_access:
                /* result:
                length (2 bytes) + content (1 byte)
                */
                result_length += 3;
                break;
#endif
            default:
                result_length += 2; /* length (2 bytes) */
                result_length += 4; /* pessimistic */
        }
    }

    result_length += 1; /* add 1 byte for isc_info_end */
    /* try insufficient result_length:
    result_length = 40;
    */

  try_alloc_result_buffer:
    Newxz(result, result_length, char);
    /* PerlIO_printf(PerlIO_stderr(), "result_length: %d\n", result_length); */

    /* call */
    isc_transaction_info(status, &(imp_dbh->tr), 
                         sizeof(request), request, 
                         result_length, result);

    if (ib_error_check(dbh, status)) {
        XSRETURN_UNDEF;
    } else {
        /* detect truncation */
        for (p = result + result_length - 1; p > result; p--) {
            if (*p != 0) {
                break;
            }
        }
        if (p > result) {
            /* PerlIO_printf(PerlIO_stderr(), "First non-null byte found at: %d\n", (p - result)); */
            if (*p == isc_info_truncated) {
                /* PerlIO_printf(PerlIO_stderr(), "Truncation detected.\n"); */

                /* increase result_length, retry allocation */
                result_length += 10;
                Safefree(result);
                result = NULL;
                goto try_alloc_result_buffer;
            }
        }

        /* parse result */
        for (p = result; p < result + result_length; ) {
            char *keyname;
            short length;
            if (*p == isc_info_end) {
                /* PerlIO_printf(PerlIO_stderr(), "isc_info_end encountered at byte: %d\n", (p - result)); */
                break;
            }
            switch (*p) {
                TX_RESBUF_CASE(id)
#if defined(FB_API_VER) && FB_API_VER >= 20
                TX_RESBUF_CASE(oldest_interesting)
                TX_RESBUF_CASE(oldest_active)
                TX_RESBUF_CASE(oldest_snapshot)
                TX_RESBUF_CASE(lock_timeout)
                case isc_info_tra_isolation:
                {
                    keyname = "isolation";
                    HV* reshv;

                    /* PerlIO_printf(PerlIO_stderr(), "Got 'isolation' at byte: %d\n", (p - result)); */
                    ++p;
                    short length = isc_vax_integer(p, 2);
                    p += 2;
                    /* PerlIO_printf(PerlIO_stderr(), "Content length: %d\n", length); */

                    if (*p == isc_info_tra_consistency) {
                        (void)hv_store(RETVAL, keyname, strlen(keyname), newSVpv("consistency", 0), 0);
                    } else if (*p == isc_info_tra_concurrency) {
                        (void)hv_store(RETVAL, keyname, strlen(keyname), newSVpv("snapshot (concurrency)", 0), 0);
                    } else if (*p == isc_info_tra_read_committed) {
                        /* warn("got 'read_committed'"); */
                        reshv = newHV();
                        if (!reshv) {
                            if (result) {
                                Safefree(result);
                            }
                            do_error(dbh, 2, "unable to allocate hash for read_committed rec/no_rec version");
                            XSRETURN_UNDEF;
                        }
                        if (*(p + 1) == isc_info_tra_no_rec_version) {
                            (void)hv_store(reshv, "read_committed", 14, newSVpv("no_rec_version", 0), 0);
                        } else if (*(p + 1) == isc_info_tra_rec_version) {
                            (void)hv_store(reshv, "read_committed", 14, newSVpv("rec_version", 0), 0);
                        } else {
                            warn("unrecognized byte");
                            continue;
                        }
                        (void)hv_store(RETVAL, keyname, strlen(keyname),
                                 newRV_noinc((SV*) reshv), 0);

                    } else {
                        PerlIO_printf(PerlIO_stderr(), "+2: got unrecognized byte: %d\n", *((char*)p));
                    }
                    p += length;
                    break;
                }
                case isc_info_tra_access: {
                    keyname = "access";
                    /* PerlIO_printf(PerlIO_stderr(), "Got 'access' at byte: %d\n", (p - result)); */
                    p++;
                    short length = isc_vax_integer(p, 2);
                    p += 2;
                    if (*p == isc_info_tra_readonly) {
                        (void)hv_store(RETVAL, keyname, strlen(keyname), newSVpvn("readonly", 8), 0);
                    } else if (*p == isc_info_tra_readwrite) {
                        (void)hv_store(RETVAL, keyname, strlen(keyname), newSVpvn("readwrite", 9), 0);
                    }
                    p += length;
                    break;
                }
#endif
                default:
                    /* PerlIO_printf(PerlIO_stderr(), "now at byte: %d\n", (p - result)); */
                    p++;
            }
        }
    }
}
#line 1800 "InterBase.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
#line 474 "InterBase.xs"
    SvREFCNT_dec(RETVAL);
#line 1805 "InterBase.c"
    }
    XSRETURN(1);
}

#undef TX_INFOBUF
#undef TX_RESBUF_CASE

XS(XS_DBD__InterBase__db_ib_set_tx_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_set_tx_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "dbh, ...");
    {
	SV *	dbh = ST(0);
#line 485 "InterBase.xs"
    STRLEN len;
    char   *tx_key, *tx_val, *tpb, *tmp_tpb;
    int    i, rc = 0;
    int    tpb_len;
    char   am_set = 0, il_set = 0, ls_set = 0;
    I32    j;
    AV     *av;
    HV     *hv;
    SV     *sv, *sv_value;
    HE     *he;

#line 1838 "InterBase.c"
	int	RETVAL;
	dXSTARG;
#line 497 "InterBase.xs"
{
    D_imp_dbh(dbh);
#ifdef PERL_UNUSED_VAR
    PERL_UNUSED_VAR(ix); /* -Wall */
#endif
    /* if no params or first parameter = 0 or undef -> reset TPB to NULL */
    if (items < 3)
    {
        if ((items == 1) || !(SvTRUE(ST(1))))
        {
            tpb     = NULL;
            tmp_tpb = NULL;
            tpb_len = 0;
            goto do_set_tpb;
        }
    }

    /* we need to know the max. size of TBP, (buffer overflow problem) */
    /* mem usage: -access_mode:     max. 1 byte                        */
    /*            -isolation_level: max. 2 bytes                       */
    /*            -lock_resolution: max. 1 byte                        */
    /*            -reserving:       max. 4 bytes + strlen(tablename)   */
    tpb_len = 5; /* 4 + 1 for tpb_version                              */

    /* we need to add the length of each table name + 4 bytes */
    for (i = 1; i < items-1; i += 2)
    {
        sv_value = ST(i + 1);
        if (strEQ(SvPV_nolen(ST(i)), "-reserving"))
            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVHV)
            {
                hv = (HV *)SvRV(sv_value);
                hv_iterinit(hv);
                while ((he = hv_iternext(hv)))
                {
                    /* retrieve the size of table name(s) */
                    HePV(he, len);
                    tpb_len += len + 4;
                }
            }
    }

    /* alloc it */
	Newx(tmp_tpb, tpb_len, char);

    /* do set TPB values */
    tpb = tmp_tpb;
    *tpb++ = isc_tpb_version3;

    for (i = 1; i < items; i += 2)
    {
        tx_key   = SvPV_nolen(ST(i));
        sv_value = ST(i + 1);

        /* value specified? */
        if (i >= items - 1)
        {
            Safefree(tmp_tpb);
            croak("You must specify parameter => value pairs, but theres no value for %s", tx_key);
        }

        /**********************************************************************/
        if (strEQ(tx_key, "-access_mode"))
        {
            if (am_set)
            {
                warn("-access_mode already set; ignoring second try!");
                continue;
            }

            tx_val = SvPV_nolen(sv_value);
            if (strEQ(tx_val, "read_write"))
                *tpb++ = isc_tpb_write;
            else if (strEQ(tx_val, "read_only"))
                *tpb++ = isc_tpb_read;
            else
            {
                Safefree(tmp_tpb);
                croak("Unknown -access_mode value %s", tx_val);
            }

            am_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-isolation_level"))
        {
            if (il_set)
            {
                warn("-isolation_level already set; ignoring second try!");
                continue;
            }

            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVAV)
            {
                av = (AV *)SvRV(sv_value);

                /* sanity check */
                for (j = 0; (j <= av_len(av)) && !rc; j++)
                {
                    sv = *av_fetch(av, j, FALSE);
                    if (strEQ(SvPV_nolen(sv), "read_committed"))
                    {
                        rc = 1;
                        *tpb++ = isc_tpb_read_committed;
                    }
                }

                if (!rc)
                {
                    Safefree(tmp_tpb);
                    croak("Invalid -isolation_level value");
                }

                for (j = 0; j <= av_len(av); j++)
                {
                    tx_val = SvPV_nolen(*(av_fetch(av, j, FALSE)));
                    if (strEQ(tx_val, "record_version"))
                    {
                        *tpb++ = isc_tpb_rec_version;
                        break;
                    }
                    else if (strEQ(tx_val, "no_record_version"))
                    {
                        *tpb++ = isc_tpb_no_rec_version;
                        break;
                    }
                    else if (!strEQ(tx_val, "read_committed"))
                    {
                        Safefree(tmp_tpb);
                        croak("Unknown -isolation_level value %s", tx_val);
                    }
                }
            }
            else
            {
                tx_val = SvPV_nolen(sv_value);
                if (strEQ(tx_val, "read_committed"))
                    *tpb++ = isc_tpb_read_committed;
                else if (strEQ(tx_val, "snapshot"))
                    *tpb++ = isc_tpb_concurrency;
                else if (strEQ(tx_val, "snapshot_table_stability"))
                    *tpb++ = isc_tpb_consistency;
                else
                {
                    Safefree(tmp_tpb);
                    croak("Unknown -isolation_level value %s", tx_val);
                }
            }

            il_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-lock_resolution"))
        {
            if (ls_set)
            {
                warn("-lock_resolution already set; ignoring second try!");
                continue;
            }

            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVHV) {
#if defined(FB_API_VER) && FB_API_VER >= 20
                hv = (HV *)SvRV(sv_value);
                if (hv_exists(hv, "wait", 4)) {
                    *tpb++ = isc_tpb_wait;
                    sv = *hv_fetch(hv, "wait", 4, FALSE);
                    if (SvIOK(sv)) {
                        IV lock_timeout = SvIV(sv);
                        if (lock_timeout < 0) {
                            do_error(dbh, 2, "Wait timeout value must be positive integer");
                            XSRETURN_UNDEF;
                        } else if (lock_timeout > 0) {
                            *tpb++ = isc_tpb_lock_timeout;
                            *tpb++ = sizeof(ISC_LONG);      /* length = 4 bytes */
                            *(ISC_LONG*)tpb = lock_timeout; /* infinite timeout */
                            tpb += sizeof(ISC_LONG);
                        }
                    } else {
                        do_error(dbh, 2, "Wait timeout value must be positive integer");
                        XSRETURN_UNDEF;
                    }
                } else {
                    do_error(dbh, 2, "The only valid key is 'wait'");
                    XSRETURN_UNDEF;
                }
#else
                do_error(dbh, 2, "Hashref unsupported. Must be compiled with Firebird 2.0 client library");
                XSRETURN_UNDEF;
#endif
            } else {
                tx_val = SvPV_nolen(sv_value);
                if (strEQ(tx_val, "wait"))
                    *tpb++ = isc_tpb_wait;
                else if (strEQ(tx_val, "no_wait"))
                    *tpb++ = isc_tpb_nowait;
                else
                {
                    Safefree(tmp_tpb);
                    croak("Unknown transaction parameter %s", tx_val);
                }
            }
            ls_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-reserving"))
        {
            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVHV)
            {
                char *table_name;
                HV *table_opts;
                hv = (HV *)SvRV(sv_value);
                hv_iterinit(hv);
                while ((he = hv_iternext(hv)))
                {
                    /* check val type */
                    if (SvROK(HeVAL(he)) && SvTYPE(SvRV(HeVAL(he))) == SVt_PVHV)
                    {
                        table_opts = (HV*)SvRV(HeVAL(he));

                        if (hv_exists(table_opts, "access", 6))
                        {
                            /* access is optional */
                            sv = *hv_fetch(table_opts, "access", 6, FALSE);
                            if (strnEQ(SvPV_nolen(sv), "shared", 6))
                                *tpb++ = isc_tpb_shared;
                            else if (strnEQ(SvPV_nolen(sv), "protected", 9))
                                *tpb++ = isc_tpb_protected;
                            else
                            {
                                Safefree(tmp_tpb);
                                croak("Invalid -reserving access value");
                            }
                        }

                        if (hv_exists(table_opts, "lock", 4))
                        {
                            /* lock is required */
                            sv = *hv_fetch(table_opts, "lock", 4, FALSE);
                            if (strnEQ(SvPV_nolen(sv), "read", 4))
                               *tpb++ = isc_tpb_lock_read;
                            else if (strnEQ(SvPV_nolen(sv), "write", 5))
                               *tpb++ = isc_tpb_lock_write;
                            else
                            {
                              Safefree(tmp_tpb);
                              croak("Invalid -reserving lock value");
                            }
                        }
                        else /* lock */
                        {
                            Safefree(tmp_tpb);
                            croak("Lock value is required in -reserving");
                        }

                        /* add the table name to TPB */
                        table_name = HePV(he, len);
                        *tpb++ = len + 1;
                        {
                            unsigned int k;
                            for (k = 0; k < len; k++)
                                *tpb++ = toupper(*table_name++);
                        }
                        *tpb++ = 0;
                    } /* end hashref check*/
                    else
                    {
                        Safefree(tmp_tpb);
                        croak("Reservation for a given table must be hashref.");
                    }
                } /* end of while() */
            }
            else
            {
                Safefree(tmp_tpb);
                croak("Invalid -reserving value. Must be hashref.");
            }
        } /* end table reservation */
        else
        {
            Safefree(tmp_tpb);
            croak("Unknown transaction parameter %s", tx_key);
        }
    }

    /* an ugly label... */
    do_set_tpb:

    Safefree(imp_dbh->tpb_buffer);
    imp_dbh->tpb_buffer = tmp_tpb;
    imp_dbh->tpb_length = tpb - imp_dbh->tpb_buffer;

    /* for AutoCommit: commit current transaction */
    if (DBIc_has(imp_dbh, DBIcf_AutoCommit))
    {
        imp_dbh->sth_ddl++;
        ib_commit_transaction(dbh, imp_dbh);
    }
    RETVAL = 1;
}
#line 2141 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define DB_INFOBUF(name, len) \
if (strEQ(item, #name)) { \
    *p++ = (char) isc_info_##name; \
    res_len += len + 3; \
    item_buf_len++; \
    continue; \
}
#define DB_RESBUF_CASEHDR(name) \
case isc_info_##name:\
    keyname = #name;

XS(XS_DBD__InterBase__db_ib_database_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_database_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "dbh, ...");
    {
	SV *	dbh = ST(0);
#line 819 "InterBase.xs"
    unsigned int i, count;
    char  item_buf[30], *p, *old_p;
    char *res_buf;
    short item_buf_len, res_len;
    AV    *av;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 2177 "InterBase.c"
	HV *	RETVAL;
#line 826 "InterBase.xs"
{
    D_imp_dbh(dbh);

    /* process input params, count max. result buffer length */
    p = item_buf;
    res_len = 0;
    item_buf_len = 0;

    /* array or array ref? */
    if (items == 2 && SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV)
    {
        av    = (AV *)SvRV(ST(1));
        count = av_len(av) + 1;
    }
    else
    {
        av    = NULL;
        count = items;
    }

    /* loop thru all elements */
    for (i = 0; i < count; i++)
    {
        char *item;

        /* fetch from array or array ref? */
        if (av)
            item = SvPV_nolen(*av_fetch(av, i, FALSE));
        else
            item = SvPV_nolen(ST(i + 1));

        /* database characteristics */
        DB_INFOBUF(allocation,        4);
        DB_INFOBUF(base_level,        2);
        DB_INFOBUF(db_id,           513);
        DB_INFOBUF(implementation,    3);
        DB_INFOBUF(no_reserve,        1);
#ifdef IB_API_V6
        DB_INFOBUF(db_read_only,      1);
#endif
        DB_INFOBUF(ods_minor_version, 1);
        DB_INFOBUF(ods_version,       1);
        DB_INFOBUF(page_size,         4);
        DB_INFOBUF(version,         257);
#ifdef IB_API_V6
        DB_INFOBUF(db_sql_dialect,    1);
#endif

        /* environmental characteristics */
        DB_INFOBUF(current_memory,    4);
        DB_INFOBUF(forced_writes,     1);
        DB_INFOBUF(max_memory,        4);
        DB_INFOBUF(num_buffers,       4);
        DB_INFOBUF(sweep_interval,    4);
        DB_INFOBUF(user_names,     1024); /* can be more, can be less */

        /* performance statistics */
        DB_INFOBUF(fetches, 4);
        DB_INFOBUF(marks,   4);
        DB_INFOBUF(reads,   4);
        DB_INFOBUF(writes,  4);
#if defined(FB_API_VER) && FB_API_VER >= 20
        /* FB 2.0 */
        DB_INFOBUF(active_tran_count, 4);
        DB_INFOBUF(creation_date,     sizeof(ISC_TIMESTAMP)); /* 2 x 4 bytes */
#endif
        /* database operation counts */
        /* XXX - not implemented (complicated: returns a descriptor for _each_
           table...how to fetch / store this??) but do we really need these? */
    }

    /* the end marker */
    *p++ = isc_info_end;
    item_buf_len++;

    /* allocate the result buffer */
    res_len += 256; /* add some safety...just in case */
	Newx(res_buf, res_len, char);

    /* call the function */
    isc_database_info(status, &(imp_dbh->db), item_buf_len, item_buf,
                      res_len, res_buf);

    if (ib_error_check(dbh, status))
    {
        Safefree(res_buf);
        XSRETURN_UNDEF; // croak("isc_database_info failed!");
    }

    /* fill hash with key/value pairs */
    RETVAL = newHV();
    for (p = res_buf; *p != isc_info_end; )
    {
        char *keyname;
        char item   = *p++;
        int  length = isc_vax_integer (p, 2);
        p += 2;
        old_p = p;

        switch (item)
        {
            /******************************************************************/
            /* database characteristics */
            DB_RESBUF_CASEHDR(allocation)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(base_level)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(++p, 1)), 0);
                break;

            DB_RESBUF_CASEHDR(db_id)
            {
                HV *reshv = newHV();
                ISC_LONG slen;

                (void)hv_store(reshv, "connection", 10,
                         (isc_vax_integer(p++, 1) == 2)?
                             newSVpv("local", 0):
                             newSVpv("remote", 0),
                         0);

                slen = isc_vax_integer(p++, 1);
                (void)hv_store(reshv, "database", 8, newSVpvn(p, slen), 0);
                p += slen;

                slen = isc_vax_integer(p++, 1);
                (void)hv_store(reshv, "site", 8, newSVpvn(p, slen), 0);

                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newRV_noinc((SV *) reshv), 0);
                break;
            }

            DB_RESBUF_CASEHDR(implementation)
            {
                HV *reshv = newHV();

                (void)hv_store(reshv, "implementation", 14,
                         newSViv(isc_vax_integer(++p, 1)), 0);

                (void)hv_store(reshv, "class", 5,
                         newSViv(isc_vax_integer(++p, 1)), 0);

                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newRV_noinc((SV *) reshv), 0);

                break;
            }

            DB_RESBUF_CASEHDR(no_reserve)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#ifdef IB_API_V6
            DB_RESBUF_CASEHDR(db_read_only)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#endif
            DB_RESBUF_CASEHDR(ods_minor_version)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(ods_version)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(page_size)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(version)
            {
                ISC_LONG slen;
                slen = isc_vax_integer(++p, 1);
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSVpvn(++p, slen), 0);
                break;
            }
#ifdef isc_dpb_sql_dialect
            DB_RESBUF_CASEHDR(db_sql_dialect)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#endif

            /******************************************************************/
            /* environmental characteristics */
            DB_RESBUF_CASEHDR(current_memory)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(forced_writes)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(max_memory)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(num_buffers)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(sweep_interval)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(user_names)
            {
                AV *avres;
                SV **svp;
                ISC_LONG slen;

                /* array already existing? no -> create */
                if (!hv_exists(RETVAL, "user_names", 10))
                {
                    avres = newAV();
                    (void)hv_store(RETVAL, "user_names", 10,
                             newRV_noinc((SV *) avres), 0);
                }
                else
                {
                    svp = hv_fetch(RETVAL, "user_names", 10, 0);
                    if (!svp || !SvROK(*svp))
                    {
                        Safefree(res_buf);
                        croak("Error fetching hash value");
                    }

                    avres = (AV *) SvRV(*svp);
                }

                /* add value to the array */
                slen = isc_vax_integer(p++, 1);
                av_push(avres, newSVpvn(p, slen));

                break;
            }

            /******************************************************************/
            /* performance statistics */
            DB_RESBUF_CASEHDR(fetches)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(marks)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(reads)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(writes)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#if defined(FB_API_VER) && FB_API_VER >= 20
            /* FB 2.0 */
            DB_RESBUF_CASEHDR(active_tran_count)
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                        newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(creation_date)
            {
                struct tm times;
                ISC_TIMESTAMP cdatetime;
                char tbuf[100];
				Zero(tbuf, sizeof(tbuf), char);
                cdatetime.timestamp_date = isc_vax_integer(p, sizeof(ISC_DATE));
                cdatetime.timestamp_time = isc_vax_integer(p + sizeof(ISC_DATE), sizeof(ISC_TIME));
                isc_decode_timestamp(&cdatetime, &times);
                strftime(tbuf, sizeof(tbuf), "%c", &times);
                (void)hv_store(RETVAL, keyname, strlen(keyname),
                         newSVpvn(tbuf, strlen(tbuf)), 0);
                break;
            }
#endif

            default:
                break;
        }

        p = old_p + length;
    }

    /* don't leak */
    Safefree(res_buf);
}
#line 2485 "InterBase.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
#line 1135 "InterBase.xs"
    SvREFCNT_dec(RETVAL);
#line 2490 "InterBase.c"
    }
    XSRETURN(1);
}

#undef DB_INFOBUF
#undef DB_RESBUF_CASEHDR

XS(XS_DBD__InterBase__db_ib_init_event); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_init_event)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "dbh, ...");
    {
	SV *	dbh = ST(0);
#line 1146 "InterBase.xs"
    char *CLASS = "DBD::InterBase::Event";
    int i;
    D_imp_dbh(dbh);
#line 2514 "InterBase.c"
	IB_EVENT *	RETVAL;
#line 1150 "InterBase.xs"
{
    unsigned short cnt = items - 1;

    DBI_TRACE_imp_xxh(imp_dbh, 2, (DBIc_LOGPIO(imp_dbh), "Entering init_event(), %d items..\n", cnt));

    if (cnt > 0)
    {
        /* check for max number of events in a single call to event block allocation */
        if (cnt > MAX_EVENTS)
            croak("Max number of events exceeded.");

		Newx(RETVAL, 1, IB_EVENT);

        /* init members */
        RETVAL->dbh           = imp_dbh;
        RETVAL->event_buffer  = NULL;
        RETVAL->result_buffer = NULL;
        RETVAL->id            = 0;
        RETVAL->num           = cnt;
        RETVAL->perl_cb       = NULL;
        RETVAL->state         = INACTIVE;
        RETVAL->exec_cb       = 0;

		Newx(RETVAL->names, MAX_EVENTS, char *);

        for (i = 0; i < MAX_EVENTS; i++)
        {
            if (i < cnt) {
                /* dangerous! 
                *(RETVAL->names + i) = SvPV_nolen(ST(i + 1));
                */
				Newx(RETVAL->names[i], SvCUR(ST(i + 1)) + 1, char);
                strcpy(RETVAL->names[i], SvPV_nolen(ST(i + 1)));
            }
            else
                *(RETVAL->names + i) = NULL;
        }

        RETVAL->epb_length = (short) isc_event_block(
            &(RETVAL->event_buffer),
            &(RETVAL->result_buffer),
            cnt,
            *(RETVAL->names +  0),
            *(RETVAL->names +  1),
            *(RETVAL->names +  2),
            *(RETVAL->names +  3),
            *(RETVAL->names +  4),
            *(RETVAL->names +  5),
            *(RETVAL->names +  6),
            *(RETVAL->names +  7),
            *(RETVAL->names +  8),
            *(RETVAL->names +  9),
            *(RETVAL->names + 10),
            *(RETVAL->names + 11),
            *(RETVAL->names + 12),
            *(RETVAL->names + 13),
            *(RETVAL->names + 14));
    }
    else
        croak("Names of the events in interest are not specified");
    {
        ISC_STATUS status[ISC_STATUS_LENGTH];
		ISC_ULONG ecount[15];
        isc_wait_for_event(status, &(imp_dbh->db), RETVAL->epb_length, RETVAL->event_buffer,
                       RETVAL->result_buffer);
        if (ib_error_check(dbh, status))
            XSRETURN_UNDEF; //croak("error in isc_wait_for_event()");
        isc_event_counts(ecount, RETVAL->epb_length, RETVAL->event_buffer,
                       RETVAL->result_buffer);
    }
    DBI_TRACE_imp_xxh(imp_dbh, 2, (DBIc_LOGPIO(imp_dbh), "Leaving init_event()\n"));
}
#line 2589 "InterBase.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );

    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_ib_register_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_register_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, ev, perl_cb");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
	SV *	perl_cb = ST(2);
#line 1232 "InterBase.xs"
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);
#line 2615 "InterBase.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_register_callback() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1235 "InterBase.xs"
{
    DBI_TRACE_imp_xxh(imp_dbh, 2, (DBIc_LOGPIO(imp_dbh), "Entering register_callback()..\n"));

    /* save the perl callback function */
    if (ev->perl_cb == (SV*)NULL) 
        ev->perl_cb = newSVsv(perl_cb);
    else {
        if (_cancel_callback(dbh, ev))
            SvSetSV(ev->perl_cb, perl_cb);
        else
            XSRETURN_UNDEF;
    }
    /* set up the events */
    isc_que_events(
        status,
        &(imp_dbh->db),
        &(ev->id),
        ev->epb_length,
        ev->event_buffer,
        (ISC_EVENT_CALLBACK)_async_callback,
        ev);
    if (ib_error_check(dbh, status))
        XSRETURN_UNDEF;
    else
        RETVAL = 1;
    ev->state = ACTIVE;
}
#line 2653 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_ib_cancel_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_cancel_callback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, ev");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
#line 1271 "InterBase.xs"
#line 2674 "InterBase.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_cancel_callback() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1272 "InterBase.xs"
    RETVAL = _cancel_callback(dbh, ev);
#line 2686 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__db_ib_wait_event); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_wait_event)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, ev");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
#line 1282 "InterBase.xs"
    int i;
    SV **svp;
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);
#line 2711 "InterBase.c"
	HV *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_wait_event() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1287 "InterBase.xs"
{
    isc_wait_for_event(status, &(imp_dbh->db), ev->epb_length, ev->event_buffer,
                       ev->result_buffer);
    if (ib_error_check(dbh, status))
    {
        do_error(dbh, 2, "ib_wait_event() error");
        XSRETURN_UNDEF;
    }
    else
    {
	ISC_ULONG ecount[15];
        isc_event_counts(ecount, ev->epb_length, ev->event_buffer,
                         ev->result_buffer);
        RETVAL = newHV();
        for (i = 0; i < ev->num; i++) 
        {
            if (ecount[i])
            {
                DBI_TRACE_imp_xxh(imp_dbh, 2, (DBIc_LOGPIO(imp_dbh), "Event %s caught %ld times.\n", *(ev->names + i), ecount[i]));
                svp = hv_store(RETVAL, *(ev->names + i), strlen(*(ev->names + i)),
                               newSViv(ecount[i]), 0);
                if (svp == NULL)
                    croak("Bad: key '%s' not stored", *(ev->names + i));
            }
        }
    }
}
#line 2748 "InterBase.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_DBD__InterBase__Event_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__Event_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "evh");
    {
	IB_EVENT *	evh;
#line 1325 "InterBase.xs"
    int i;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 2771 "InterBase.c"

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
        evh = (IB_EVENT *)SvIV((SV*)SvRV( ST(0) ));
    else{
        warn( "DBD::InterBase::Event::DESTROY() -- evh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1328 "InterBase.xs"
{
    DBI_TRACE_imp_xxh(evh->dbh, 2, (DBIc_LOGPIO(evh->dbh), "Entering DBD::InterBase::Event::DESTROY..\n"));
#ifdef DBI_USE_THREADS
	if (PERL_GET_CONTEXT != evh->dbh->context) {
		DBI_TRACE_imp_xxh(evh->dbh, 2, (DBIc_LOGPIO(evh->dbh), 
			"DBD::InterBase::Event::DESTROY ignored because owned by thread %p not current thread %p\n",
			evh->dbh->context, (PerlInterpreter *)PERL_GET_CONTEXT)
		);
		XSRETURN(0);
	}
#endif
    for (i = 0; i < evh->num; i++)
        if (*(evh->names + i))
            Safefree(*(evh->names + i));
    if (evh->names)
        Safefree(evh->names);
    if (evh->perl_cb) {
        SvREFCNT_dec(evh->perl_cb);
        isc_cancel_events(status, &(evh->dbh->db), &(evh->id));
    }
    if (evh->event_buffer)
#ifdef INCLUDE_TYPES_PUB_H 
        isc_free((ISC_SCHAR*)evh->event_buffer);
#else
        isc_free(evh->event_buffer);
#endif
    if (evh->result_buffer)
#ifdef INCLUDE_TYPES_PUB_H 
        isc_free((ISC_SCHAR*)evh->result_buffer);
#else
        isc_free(evh->result_buffer);
#endif
}
#line 2813 "InterBase.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DBD__InterBase__st_ib_plan); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_ib_plan)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
	char *	RETVAL;
	dXSTARG;
#line 1368 "InterBase.xs"
{
    D_imp_sth(sth);
    ISC_STATUS  status[ISC_STATUS_LENGTH];
    char plan_info[1];
    char plan_buffer[PLAN_BUFFER_LEN];

    RETVAL = NULL;
	Zero(plan_buffer, sizeof(plan_buffer), char);
    plan_info[0] = isc_info_sql_get_plan;

    if (isc_dsql_sql_info(status, &(imp_sth->stmt), sizeof(plan_info), plan_info,
                  sizeof(plan_buffer), plan_buffer)) 
    {
        if (ib_error_check(sth, status))
        {
            ib_cleanup_st_prepare(imp_sth);
            XSRETURN_UNDEF;
        }
    }
    if (plan_buffer[0] == isc_info_sql_get_plan) {
        short l = (short) isc_vax_integer((char *)plan_buffer + 1, 2);
		Newx(RETVAL, l + 2, char);
        sprintf(RETVAL, "%.*s%s", l, plan_buffer + 3, "\n");
        //PerlIO_printf(PerlIO_stderr(), "Len: %d, orig len: %d\n", strlen(imp_sth->plan), l);
    }
}
#line 2860 "InterBase.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__InterBase); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__InterBase)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("DBD::InterBase::dr::dbixs_revision", XS_DBD__InterBase__dr_dbixs_revision, file);
#if XSubPPtmpAAAA
        cv = newXS("DBD::InterBase::dr::discon_all_", XS_DBD__InterBase__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::dr::disconnect_all", XS_DBD__InterBase__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::InterBase::dr::data_sources", XS_DBD__InterBase__dr_data_sources, file);
#endif
        newXS("DBD::InterBase::db::_login", XS_DBD__InterBase__db__login, file);
        newXS("DBD::InterBase::db::selectall_arrayref", XS_DBD__InterBase__db_selectall_arrayref, file);
        cv = newXS("DBD::InterBase::db::selectrow_arrayref", XS_DBD__InterBase__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::db::selectrow_array", XS_DBD__InterBase__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
#if XSubPPtmpAAAC
        newXS("DBD::InterBase::db::do", XS_DBD__InterBase__db_do, file);
#endif
#if XSubPPtmpAAAD
        newXS("DBD::InterBase::db::last_insert_id", XS_DBD__InterBase__db_last_insert_id, file);
#endif
        newXS("DBD::InterBase::db::commit", XS_DBD__InterBase__db_commit, file);
        newXS("DBD::InterBase::db::rollback", XS_DBD__InterBase__db_rollback, file);
        newXS("DBD::InterBase::db::disconnect", XS_DBD__InterBase__db_disconnect, file);
        newXS("DBD::InterBase::db::STORE", XS_DBD__InterBase__db_STORE, file);
        newXS("DBD::InterBase::db::FETCH", XS_DBD__InterBase__db_FETCH, file);
        newXS("DBD::InterBase::db::DESTROY", XS_DBD__InterBase__db_DESTROY, file);
#if XSubPPtmpAAAE
        newXS("DBD::InterBase::db::take_imp_data", XS_DBD__InterBase__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAF
        newXS("DBD::InterBase::db::data_sources", XS_DBD__InterBase__db_data_sources, file);
#endif
        newXS("DBD::InterBase::st::_prepare", XS_DBD__InterBase__st__prepare, file);
#if XSubPPtmpAAAG
        newXS("DBD::InterBase::st::rows", XS_DBD__InterBase__st_rows, file);
#endif
#if XSubPPtmpAAAH
        newXS("DBD::InterBase::st::bind_col", XS_DBD__InterBase__st_bind_col, file);
#endif
        newXS("DBD::InterBase::st::bind_param", XS_DBD__InterBase__st_bind_param, file);
        newXS("DBD::InterBase::st::bind_param_inout", XS_DBD__InterBase__st_bind_param_inout, file);
        newXS("DBD::InterBase::st::execute", XS_DBD__InterBase__st_execute, file);
#if XSubPPtmpAAAI
        newXS("DBD::InterBase::st::execute_for_fetch", XS_DBD__InterBase__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::InterBase::st::fetchrow_arrayref", XS_DBD__InterBase__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::fetch", XS_DBD__InterBase__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::InterBase::st::fetchrow_array", XS_DBD__InterBase__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::fetchrow", XS_DBD__InterBase__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::st::fetchall_arrayref", XS_DBD__InterBase__st_fetchall_arrayref, file);
        newXS("DBD::InterBase::st::finish", XS_DBD__InterBase__st_finish, file);
        newXS("DBD::InterBase::st::blob_read", XS_DBD__InterBase__st_blob_read, file);
        newXS("DBD::InterBase::st::STORE", XS_DBD__InterBase__st_STORE, file);
        cv = newXS("DBD::InterBase::st::FETCH_attrib", XS_DBD__InterBase__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::FETCH", XS_DBD__InterBase__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::st::DESTROY", XS_DBD__InterBase__st_DESTROY, file);
        newXSproto("DBD::InterBase::db::_do", XS_DBD__InterBase__db__do, file, "$$;$@");
        newXS("DBD::InterBase::db::_ping", XS_DBD__InterBase__db__ping, file);
        newXS("DBD::InterBase::db::ib_tx_info", XS_DBD__InterBase__db_ib_tx_info, file);
        cv = newXS("DBD::InterBase::db::ib_set_tx_param", XS_DBD__InterBase__db_ib_set_tx_param, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::db::set_tx_param", XS_DBD__InterBase__db_ib_set_tx_param, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::db::ib_database_info", XS_DBD__InterBase__db_ib_database_info, file);
        newXS("DBD::InterBase::db::ib_init_event", XS_DBD__InterBase__db_ib_init_event, file);
        newXS("DBD::InterBase::db::ib_register_callback", XS_DBD__InterBase__db_ib_register_callback, file);
        newXS("DBD::InterBase::db::ib_cancel_callback", XS_DBD__InterBase__db_ib_cancel_callback, file);
        newXS("DBD::InterBase::db::ib_wait_event", XS_DBD__InterBase__db_ib_wait_event, file);
        newXS("DBD::InterBase::Event::DESTROY", XS_DBD__InterBase__Event_DESTROY, file);
        newXS("DBD::InterBase::st::ib_plan", XS_DBD__InterBase__st_ib_plan, file);
    }

    /* Initialisation Section */

#line 18 "InterBase.xsi"
    items = 0;  /* avoid 'unused variable' warning */
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::InterBase::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::InterBase::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::InterBase::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#line 2995 "InterBase.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

